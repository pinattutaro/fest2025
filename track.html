<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ブラウザで相対姿勢推定 (solvePnP)</title>
  <style>
    video, canvas { display: block; margin: 0 auto; }
    #console {
        display: inline-block;
        width: 300px;
        height: 100px;
        position: fixed;
        top: 0px;
        left: 0px;
        background-color: rgba(0,0,0,0.5);
        color: white;
        font-size: 10px;
    }
  </style>
  <script src="https://docs.opencv.org/4.x/opencv.js"></script>
</head>
<body>
  <div id="console"></div>
  <video id="video" autoplay playsinline width="640" height="480"></video>
  <canvas id="canvas" width="640" height="480"></canvas>

  <script>
    let video = document.getElementById('video');
    let canvas = document.getElementById('canvas');
    let ctx = canvas.getContext('2d');

    let orb, bf;
    let firstKeypoints, firstDescriptors;
    let first3DPoints; // 開始フレームの3D座標 (Z=0)
    let firstFrame = null;

    let cameraMatrix, distCoeffs;

    async function initCamera() {
      let stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
      video.srcObject = stream;
      return new Promise(res => video.onloadedmetadata = res);
    }

    function initOpenCV() {
      orb = new cv.ORB();
      bf = new cv.BFMatcher(cv.NORM_HAMMING, true);

      firstKeypoints = new cv.KeyPointVector();
      firstDescriptors = new cv.Mat();
      first3DPoints = [];

      // 仮のカメラ内部パラメータ
      let fx = 800, fy = 800, cx = 320, cy = 240;
      cameraMatrix = cv.matFromArray(3, 3, cv.CV_64F, [
        fx, 0, cx,
        0, fy, cy,
        0, 0, 1
      ]);
      distCoeffs = cv.Mat.zeros(4, 1, cv.CV_64F);
    }

    function captureFirstFrame(mat) {
      firstFrame = mat.clone();
      orb.detectAndCompute(firstFrame, new cv.Mat(), firstKeypoints, firstDescriptors);

      // 平面上の3D座標を作る（Z=0、単位はピクセル）
      first3DPoints = [];
      for (let i = 0; i < firstKeypoints.size(); i++) {
        let pt = firstKeypoints.get(i).pt;
        first3DPoints.push(pt.x, pt.y, 0.0);
      }

      console.log("初期フレームキャプチャ完了、3D座標作成");
    }

    function processFrame(mat) {
      if (!firstFrame) {
        captureFirstFrame(mat);
        return;
      }

      let kp = new cv.KeyPointVector();
      let des = new cv.Mat();
      orb.detectAndCompute(mat, new cv.Mat(), kp, des);

      let matches = new cv.DMatchVector();
      bf.match(firstDescriptors, des, matches);

      let objectPoints = [], imagePoints = [];
      for (let i = 0; i < matches.size(); i++) {
        let m = matches.get(i);
        let pt3 = first3DPoints.slice(m.queryIdx * 3, m.queryIdx * 3 + 3);
        objectPoints.push(...pt3);

        let pt2 = kp.get(m.trainIdx).pt;
        imagePoints.push(pt2.x, pt2.y);
      }

      if (objectPoints.length >= 4) {
        let objMat = cv.matFromArray(objectPoints.length / 3, 3, cv.CV_64F, objectPoints);
        let imgMat = cv.matFromArray(imagePoints.length / 2, 2, cv.CV_64F, imagePoints);

        let rvec = new cv.Mat();
        let tvec = new cv.Mat();

        let success = cv.solvePnP(objMat, imgMat, cameraMatrix, distCoeffs, rvec, tvec, false, cv.SOLVEPNP_ITERATIVE);
        if (success) {
          console.log("回転ベクトル:", rvec.data64F);
          console.log("並進ベクトル:", tvec.data64F);
          document.getElementById('console').innerText = 
            `回転ベクトル: ${rvec.data64F}\n並進ベクトル: ${tvec.data64F}`;
        }

        objMat.delete(); imgMat.delete(); rvec.delete(); tvec.delete();
      }

      kp.delete(); des.delete(); matches.delete();
    }

    function mainLoop() {
      let frame = new cv.Mat(video.height, video.width, cv.CV_8UC4);
      ctx.drawImage(video, 0, 0, video.width, video.height);
      frame.data.set(ctx.getImageData(0, 0, video.width, video.height).data);

      let gray = new cv.Mat();
      cv.cvtColor(frame, gray, cv.COLOR_RGBA2GRAY);
      processFrame(gray);

      gray.delete(); frame.delete();
      requestAnimationFrame(mainLoop);
    }

    cv['onRuntimeInitialized'] = async () => {
      await initCamera();
      initOpenCV();
      mainLoop();
    };
  </script>
</body>
</html>
